
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">flyhorizons-bookingservice/config/setup_messaging.go (0.0%)</option>
				
				<option value="file1">flyhorizons-bookingservice/main.go (0.0%)</option>
				
				<option value="file2">flyhorizons-bookingservice/models/enums/flight_class.go (0.0%)</option>
				
				<option value="file3">flyhorizons-bookingservice/models/enums/luggage.go (0.0%)</option>
				
				<option value="file4">flyhorizons-bookingservice/repositories/base_repository.go (4.4%)</option>
				
				<option value="file5">flyhorizons-bookingservice/repositories/booking_repository.go (82.6%)</option>
				
				<option value="file6">flyhorizons-bookingservice/repositories/entity/booking_entity.go (0.0%)</option>
				
				<option value="file7">flyhorizons-bookingservice/repositories/entity/passenger_entity.go (0.0%)</option>
				
				<option value="file8">flyhorizons-bookingservice/repositories/entity/seat_entity.go (0.0%)</option>
				
				<option value="file9">flyhorizons-bookingservice/repositories/entity/seat_option_entity.go (0.0%)</option>
				
				<option value="file10">flyhorizons-bookingservice/repositories/seat_repository.go (0.0%)</option>
				
				<option value="file11">flyhorizons-bookingservice/routes/booking_router.go (60.9%)</option>
				
				<option value="file12">flyhorizons-bookingservice/routes/seat_router.go (71.4%)</option>
				
				<option value="file13">flyhorizons-bookingservice/server/server.go (0.0%)</option>
				
				<option value="file14">flyhorizons-bookingservice/services/authentication/gateway_auth_middleware.go (0.0%)</option>
				
				<option value="file15">flyhorizons-bookingservice/services/booking_service.go (71.0%)</option>
				
				<option value="file16">flyhorizons-bookingservice/services/converter/booking_converter.go (100.0%)</option>
				
				<option value="file17">flyhorizons-bookingservice/services/converter/passenger_converter.go (100.0%)</option>
				
				<option value="file18">flyhorizons-bookingservice/services/converter/seat_converter.go (100.0%)</option>
				
				<option value="file19">flyhorizons-bookingservice/services/errors/booking_exists_error.go (0.0%)</option>
				
				<option value="file20">flyhorizons-bookingservice/services/errors/booking_not_found_error.go (0.0%)</option>
				
				<option value="file21">flyhorizons-bookingservice/services/seat_service.go (100.0%)</option>
				
				<option value="file22">flyhorizons-bookingservice/tests/load/utils/load_test_utils.go (0.0%)</option>
				
				<option value="file23">flyhorizons-bookingservice/tests/mocks/booking_repository_mock.go (0.0%)</option>
				
				<option value="file24">flyhorizons-bookingservice/tests/mocks/booking_service_mock.go (0.0%)</option>
				
				<option value="file25">flyhorizons-bookingservice/tests/mocks/gateway_auth_middleware_mock.go (0.0%)</option>
				
				<option value="file26">flyhorizons-bookingservice/tests/mocks/seat_repository_mock.go (0.0%)</option>
				
				<option value="file27">flyhorizons-bookingservice/tests/mocks/seat_service_mock.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "log"
        "os"

        "github.com/joho/godotenv"
        "github.com/rabbitmq/amqp091-go"
)

type SetupMessaging struct {
}

func InitializeRabbitMQ() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error occurred while loading the .env file: %s", err)
        }</span>

        <span class="cov0" title="0">connection, err := amqp091.Dial(os.Getenv("RABBITMQ_URL"))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error occurred while connecting to RabbitMQ: %s", err)
        }</span>

        <span class="cov0" title="0">channel, err := connection.Channel()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error occurred while opening the RabbitMQ channel: %s", err)
        }</span>

        // Declare the queue
        <span class="cov0" title="0">_, err = channel.QueueDeclare(
                "booking_email_queue",
                true,  // Durable
                false, // Auto Delete
                false, // Exclusive
                false, // No Wait
                nil,   // Arguments
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error occurred while declaring the queue: %s", err)
        }</span>

        <span class="cov0" title="0">RabbitMQClient = &amp;RabbitMQ{
                Connection: connection,
                Channel:    channel,
        }

        log.Println("RabbitMQ has been initialized successfully.")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flyhorizons-bookingservice/server"
        "os"
)

// Run in a production environment: $env:ENV="production"; go run main.go

func main() <span class="cov0" title="0">{
        env := os.Getenv("ENV")
        if env == "" </span><span class="cov0" title="0">{
                env = "production"
        }</span>

        <span class="cov0" title="0">server.StartApp(env)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package enums

type FlightClass int

const (
        Economy  FlightClass = 0
        Business FlightClass = 1
)

func FlightClassFromInt(value int) FlightClass <span class="cov0" title="0">{
        switch value </span>{
        case 0:<span class="cov0" title="0">
                return Economy</span>
        case 1:<span class="cov0" title="0">
                return Business</span>
        default:<span class="cov0" title="0">
                return Economy</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package enums

import "encoding/json"

type Luggage string

const (
        SmallBag        Luggage = "SmallBag"
        CabinBag        Luggage = "CabinBag"
        Cargo20kg       Luggage = "Cargo20kg"
        Cargo30kg       Luggage = "Cargo30kg"
        SportsEquipment Luggage = "SportsEquipment"
        BabyCarrier     Luggage = "BabyCarrier"
)

func LuggageClassesFromJSONString(jsonInput string) []Luggage <span class="cov0" title="0">{
        var luggageStrings []string
        if err := json.Unmarshal([]byte(jsonInput), &amp;luggageStrings); err != nil </span><span class="cov0" title="0">{
                return []Luggage{}
        }</span>

        <span class="cov0" title="0">var result []Luggage
        for _, item := range luggageStrings </span><span class="cov0" title="0">{
                switch Luggage(item) </span>{
                case SmallBag, CabinBag, Cargo20kg, Cargo30kg, SportsEquipment, BabyCarrier:<span class="cov0" title="0">
                        result = append(result, Luggage(item))</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func JSONStringToLuggageClasses(luggage []Luggage) string <span class="cov0" title="0">{
        jsonData, err := json.Marshal(luggage)
        if err != nil </span><span class="cov0" title="0">{
                return "[]"
        }</span>
        <span class="cov0" title="0">return string(jsonData)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package repositories

import (
        "database/sql"
        "fmt"
        "log"
        "os"

        "github.com/joho/godotenv"
        "gorm.io/driver/sqlserver"
        "gorm.io/gorm"
)

type BaseRepository struct {
        DB *gorm.DB
}

func (dal *BaseRepository) LoadDBConfig() string <span class="cov0" title="0">{
        // Get the environment from the ENV variable
        env := os.Getenv("ENV")
        fmt.Println("Current environment:", env)

        // Load the correct .env file based on the environment
        var err error
        if env == "production" </span><span class="cov0" title="0">{
                err = godotenv.Overload(".env.prod")
                fmt.Println("Accessing production .env file")
        }</span> else<span class="cov0" title="0"> if env == "testing" </span><span class="cov0" title="0">{
                err = godotenv.Overload(".env.test")
                fmt.Println("Accessing testing .env file")
        }</span> else<span class="cov0" title="0"> {
                err = godotenv.Overload(".env")
                fmt.Printf("Accessing development .env file")
        }</span>

        // Add more detailed error handling and logging
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error loading .env file for environment '%s': %v\n", env, err)
                log.Fatal("Error loading environment variables")
        }</span>

        // Retrieve environment variables
        <span class="cov0" title="0">programType := os.Getenv("TYPE")
        server := os.Getenv("DB_SERVER")
        port := os.Getenv("DB_PORT")
        user := os.Getenv("DB_USER")
        password := os.Getenv("DB_PASSWORD")
        database := os.Getenv("DB_DATABASE")

        fmt.Printf("Program Type %s\n", programType)
        fmt.Printf("Database: %s\n", database)

        if server == "" || port == "" || user == "" || password == "" || database == "" </span><span class="cov0" title="0">{
                log.Fatalf("Missing environment variables for database connection")
        }</span>

        // Build and return database connection string
        <span class="cov0" title="0">connString := fmt.Sprintf("server=%s;user id=%s;password=%s;port=%s;database=%s;",
                server, user, password, port, database)
        return connString</span>
}

func (dal *BaseRepository) CreateConnection() (*gorm.DB, error) <span class="cov8" title="1">{
        if dal.DB != nil </span><span class="cov8" title="1">{
                return dal.DB, nil
        }</span>

        <span class="cov0" title="0">connString := dal.LoadDBConfig()
        if connString == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load database configuration: environment variables missing")
        }</span>

        // Connect to database
        <span class="cov0" title="0">sqlDB, err := sql.Open("sqlserver", connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating connection pool: %w", err)
        }</span>

        // Ensure a successful connection by pinging the database
        <span class="cov0" title="0">err = sqlDB.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error pinging the database: %w", err)
        }</span>

        // Initialize GORM
        <span class="cov0" title="0">db, err := gorm.Open(sqlserver.New(sqlserver.Config{
                Conn: sqlDB,
        }), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error initializing GORM: %w", err)
        }</span>

        <span class="cov0" title="0">dal.DB = db
        return dal.DB, nil</span>
}

func (dal *BaseRepository) CloseConnection() <span class="cov0" title="0">{
        if dal.DB != nil </span><span class="cov0" title="0">{
                sqlDB, _ := dal.DB.DB()
                sqlDB.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repositories

import (
        entities "flyhorizons-bookingservice/repositories/entity"
        "flyhorizons-bookingservice/services/interfaces"
        "log"
)

type BookingRepository struct {
        *BaseRepository
}

var _ interfaces.BookingRepository = (*BookingRepository)(nil)

func NewBookingRepository(baseRepo *BaseRepository) *BookingRepository <span class="cov8" title="1">{
        return &amp;BookingRepository{
                BaseRepository: baseRepo,
        }
}</span>

func (repo *BookingRepository) GetAll() []entities.BookingEntity <span class="cov8" title="1">{
        var bookings []entities.BookingEntity

        repo.DB.Preload("Passengers").Preload("Seats").Find(&amp;bookings)

        return bookings
}</span>

func (repo *BookingRepository) GetByUserID(userID int) []entities.BookingEntity <span class="cov8" title="1">{
        db, _ := repo.CreateConnection()

        var bookings []entities.BookingEntity

        // This preloads the related Passengers and Seats
        db.Preload("Passengers").Preload("Seats").Where("UserID = ?", userID).Find(&amp;bookings)

        return bookings
}</span>

func (repo *BookingRepository) Create(bookingEntity entities.BookingEntity) entities.BookingEntity <span class="cov8" title="1">{
        db, _ := repo.CreateConnection()

        db.Create(&amp;bookingEntity)

        return bookingEntity
}</span>

func (repo *BookingRepository) DeleteByBookingID(bookingID int) bool <span class="cov8" title="1">{
        db, _ := repo.CreateConnection()

        // Delete associated passengers
        if err := db.Where("BookingID = ?", bookingID).Delete(&amp;entities.PassengerEntity{}).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting associated passengers: %v", err)
                return false
        }</span>

        // Delete associated seats
        <span class="cov8" title="1">if err := db.Where("BookingID = ?", bookingID).Delete(&amp;entities.SeatEntity{}).Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting associated seats: %v", err)
                return false
        }</span>

        // Delete booking
        <span class="cov8" title="1">result := repo.DB.Delete(&amp;entities.BookingEntity{}, bookingID)

        return result.Error == nil &amp;&amp; result.RowsAffected &gt; 0</span>
}

func (repo *BookingRepository) Update(flightEntity entities.BookingEntity) entities.BookingEntity <span class="cov8" title="1">{
        db, _ := repo.CreateConnection()

        db.Save(&amp;flightEntity)

        return flightEntity
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package entities

import "time"

type BookingEntity struct {
        ID          int               `gorm:"column:ID;primaryKey"`
        UserID      int               `gorm:"column:UserID"`
        FlightCode  string            `gorm:"column:FlightCode"`
        FlightClass int               `gorm:"column:FlightClass"`
        CreatedAt   time.Time         `gorm:"column:CreatedAt"`
        Passengers  []PassengerEntity `gorm:"foreignKey:BookingID;references:ID"` // One-to-many relationship
        Seats       []SeatEntity      `gorm:"foreignKey:BookingID;references:ID"` // One-to-many relationship
        Luggage     string            `gorm:"column:Luggage;type:string"`         // JSON list of integers (string)
}

// Override the default table name
func (BookingEntity) TableName() string <span class="cov0" title="0">{
        return "Booking"
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package entities

import "time"

type PassengerEntity struct {
        ID             int           `gorm:"column:ID;primaryKey"`
        BookingID      int           `gorm:"column:BookingID;index"`             // Foreign key for the Booking table
        Booking        BookingEntity `gorm:"foreignKey:BookingID;references:ID"` // Relationship to BookingEntity
        FullName       string        `gorm:"column:FullName"`
        DateOfBirth    time.Time     `gorm:"column:DateOfBirth"`
        PassportNumber string        `gorm:"column:PassportNumber"`
        Email          string        `gorm:"column:Email"`
}

// Override the default table name
func (PassengerEntity) TableName() string <span class="cov0" title="0">{
        return "Passenger"
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package entities

type SeatEntity struct {
        ID        int           `gorm:"column:ID;primaryKey"`
        BookingID int           `gorm:"column:BookingID;index"`             // Foreign key for the Booking table
        Booking   BookingEntity `gorm:"foreignKey:BookingID;references:ID"` // Relationship to BookingEntity
        Row       int           `gorm:"column:Row"`
        Column    string        `gorm:"column:Column"`
}

// Override the default table name
func (SeatEntity) TableName() string <span class="cov0" title="0">{
        return "Seat"
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package entities

type SeatOptionEntity struct {
        ID     int    `gorm:"column:ID;primaryKey;autoIncrement"`
        Row    int    `gorm:"column:row;not null"`
        Column string `gorm:"column:seat_column;type:char(1);not null"`
        Status bool   `gorm:"column:status"`
}

// Override the default table name
func (SeatOptionEntity) TableName() string <span class="cov0" title="0">{
        return "SeatOption"
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package repositories

import (
        entities "flyhorizons-bookingservice/repositories/entity"
        "fmt"
)

type SeatRepository struct {
        *BaseRepository
}

func NewSeatRepository(baseRepo *BaseRepository) *SeatRepository <span class="cov0" title="0">{
        return &amp;SeatRepository{
                BaseRepository: baseRepo,
        }
}</span>

func (r *SeatRepository) GetByFlightCode(flightCode string) ([]entities.SeatOptionEntity, error) <span class="cov0" title="0">{
        db, err := r.CreateConnection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create DB connection: %v", err)
        }</span>

        <span class="cov0" title="0">var results []entities.SeatOptionEntity

        err = db.Raw(`
                SELECT 
                        so.Row AS row,
                        so.[Column] AS seat_column,
                        CASE 
                                WHEN s.BookingID IS NULL THEN 1  -- Available (no booking)
                                ELSE 0  -- Booked (has a booking)
                        END AS status
                FROM 
                        SeatOption so
                LEFT JOIN 
                        Seat s ON so.Row = s.Row AND so.[Column] = s.[Column]
                LEFT JOIN 
                        Booking b ON s.BookingID = b.ID 
                WHERE 
                        (b.FlightCode = ? OR b.FlightCode IS NULL)  -- Select only bookings for the FlightID
                ORDER BY 
                        so.Row, so.[Column]
        `, flightCode).Scan(&amp;results).Error

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error fetching seat options for flightCode %s: %v\n", flightCode, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package routes

import (
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/services/errors"
        "flyhorizons-bookingservice/services/interfaces"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// Handles the booking CRUD functionality
func RegisterBookingRoutes(router *gin.Engine, bookingService interfaces.BookingService, authMiddleware interfaces.GatewayAuthMiddleware) <span class="cov8" title="1">{
        // Public routes
        router.DELETE("/bookings/:ID", func(ctx *gin.Context) </span><span class="cov8" title="1">{
                bookingIDString := ctx.Param("ID")

                // Convert string to int
                bookingID, err := strconv.Atoi(bookingIDString)

                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bookingID"})
                        return
                }</span>

                <span class="cov8" title="1">success, err := bookingService.DeleteByBookingID(bookingID)
                if err != nil </span><span class="cov8" title="1">{
                        if _, ok := err.(*errors.BookingNotFoundError); ok </span><span class="cov8" title="1">{
                                ctx.JSON(http.StatusNotFound, gin.H{"message": err.Error()}) // 404 Not Found
                                return
                        }</span>
                        <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                        return</span>
                }
                // Uses success to confirm the deletion
                <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusOK, gin.H{
                                "message": "Booking deleted successfully",
                        })
                }</span> else<span class="cov0" title="0"> {
                        ctx.JSON(http.StatusInternalServerError, gin.H{
                                "message": "Failed to delete Booking, but no error has occurred",
                        })
                }</span>
        })

        <span class="cov8" title="1">router.POST("/bookings", func(ctx *gin.Context) </span><span class="cov0" title="0">{
                var booking models.Booking

                if err := ctx.ShouldBindJSON(&amp;booking); err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov0" title="0">postBooking, err := bookingService.Create(booking)
                if err != nil </span><span class="cov0" title="0">{
                        // 409 Conflict
                        if _, ok := err.(*errors.BookingExistsError); ok </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusConflict, gin.H{"message": err.Error()})
                                return
                        }</span>
                        // 500 Internal Server Error
                        <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                        return</span>
                }
                <span class="cov0" title="0">ctx.JSON(http.StatusCreated, postBooking)</span>
        })

        <span class="cov8" title="1">bookingGroup := router.Group("/bookings")
        bookingGroup.Use(authMiddleware.GatewayAuthMiddleware())

        // Protected routes
        // Can only be accessible by the logged in user (userID)
        bookingGroup.GET("/", func(ctx *gin.Context) </span><span class="cov8" title="1">{
                userIDRaw, _ := ctx.Get("user_id")

                userID, ok := userIDRaw.(int)
                if !ok </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": "userID not a string"})
                        return
                }</span>

                <span class="cov8" title="1">bookings := bookingService.GetByUserID(userID)

                // Check that the bookings userID matches the logged in user
                for _, booking := range bookings </span><span class="cov8" title="1">{
                        if userID != booking.UserID </span><span class="cov8" title="1">{
                                ctx.JSON(http.StatusForbidden, gin.H{"error": "unauthorized: cannot access the bookings belonging to another user"})
                                return
                        }</span>
                }

                <span class="cov8" title="1">ctx.JSON(http.StatusOK, bookings)</span>
        })

        <span class="cov8" title="1">bookingGroup.PUT("/", func(ctx *gin.Context) </span><span class="cov8" title="1">{
                userIDRaw, _ := ctx.Get("user_id")

                userID, ok := userIDRaw.(int)
                if !ok </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": "userID not a string"})
                        return
                }</span>

                <span class="cov8" title="1">var booking models.Booking
                // Convert JSON to a Booking object
                if err := ctx.ShouldBindJSON(&amp;booking); err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                // Check if the booking userID matches the logged in user
                <span class="cov8" title="1">if userID != booking.UserID </span><span class="cov8" title="1">{
                        ctx.JSON(http.StatusForbidden, gin.H{"error": "unauthorized: cannot access the bookings belonging to another user"})
                        return
                }</span>

                <span class="cov8" title="1">put_booking, err := bookingService.Update(booking)
                if err != nil </span><span class="cov8" title="1">{
                        if _, ok := err.(*errors.BookingNotFoundError); ok </span><span class="cov8" title="1">{
                                ctx.JSON(http.StatusNotFound, gin.H{"message": err.Error()})
                                return
                        }</span>
                        <span class="cov0" title="0">ctx.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                        return</span>
                }
                <span class="cov8" title="1">ctx.JSON(http.StatusOK, put_booking)</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package routes

import (
        "flyhorizons-bookingservice/services/interfaces"
        "net/http"

        "github.com/gin-gonic/gin"
)

func RegisterSeatRoutes(router *gin.Engine, seatService interfaces.SeatService) <span class="cov8" title="1">{
        router.GET("/bookings/seats/:flightCode", func(ctx *gin.Context) </span><span class="cov8" title="1">{
                flightCode := ctx.Param("flightCode")
                seats, err := seatService.GetByFlightCode(flightCode)

                if err != nil </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">ctx.JSON(http.StatusOK, seats)</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "flyhorizons-bookingservice/config"
        "flyhorizons-bookingservice/repositories"
        "flyhorizons-bookingservice/routes"
        "flyhorizons-bookingservice/services"
        "flyhorizons-bookingservice/services/authentication"
        "flyhorizons-bookingservice/services/converter"
        "os"

        "github.com/gin-gonic/gin"
)

func StartApp(env string) <span class="cov0" title="0">{
        // Run as a production environment by default
        if env == "" </span><span class="cov0" title="0">{
                os.Setenv("ENV", "production")
        }</span> else<span class="cov0" title="0"> {
                os.Setenv("ENV", env)
        }</span>

        // Initialize RabbitMQ for messaging
        <span class="cov0" title="0">config.InitializeRabbitMQ()
        defer config.RabbitMQClient.Connection.Close()
        defer config.RabbitMQClient.Connection.Channel()

        router := gin.Default()

        // Repositories
        baseRepo := repositories.BaseRepository{}
        bookingRepo := repositories.NewBookingRepository(&amp;baseRepo)
        seatRepo := repositories.NewSeatRepository(&amp;baseRepo)

        // Converters
        bookingConverter := converter.BookingConverter{}
        passengerConverter := converter.PassengerConverter{}
        seatConverter := converter.SeatConverter{}

        // Authentication
        gatewayAuthMiddleware := authentication.NewGatewayAuthMiddleware()

        // Services
        bookingService := services.NewBookingService(bookingRepo, bookingConverter, passengerConverter, seatConverter)
        seatService := services.NewSeatService(seatRepo, seatConverter)

        // Routes
        routes.RegisterBookingRoutes(router, bookingService, gatewayAuthMiddleware)
        routes.RegisterSeatRoutes(router, seatService)

        // Run the microservice
        router.Run(":8083")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package authentication

import (
        "fmt"
        "net/http"
        "os"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v4"
        "github.com/joho/godotenv"
)

type GatewayAuthMiddlewareHandler struct{}

func (g *GatewayAuthMiddlewareHandler) GatewayAuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Load .env file
                err := godotenv.Load()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error loading .env file")
                }</span>

                <span class="cov0" title="0">JwtSecret := []byte(os.Getenv("JWT_SECRET"))

                // Get JWT token from Authorization header
                authHeader := c.GetHeader("Authorization")

                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing or invalid Authorization header"})
                        return
                }</span>

                <span class="cov0" title="0">tokenStr := strings.TrimPrefix(authHeader, "Bearer ")

                // Parse the JWT token
                token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return JwtSecret, nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        fmt.Println("JWT parsing failed:", err)
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid JWT token"})
                        return
                }</span>

                // Extract claims
                <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid JWT claims"})
                        return
                }</span>

                <span class="cov0" title="0">fmt.Println("--- Extracted JWT Claims ---")
                for k, v := range claims </span><span class="cov0" title="0">{
                        fmt.Printf("%s: %v\n", k, v)
                }</span>

                // Set claims
                <span class="cov0" title="0">if sub, ok := claims["sub"].(float64); ok </span><span class="cov0" title="0">{
                        c.Set("user_id", int(sub))
                        c.Set("sub", int(sub))
                }</span>
                <span class="cov0" title="0">if role, ok := claims["role"].(string); ok </span><span class="cov0" title="0">{
                        c.Set("role", role)
                }</span>
                <span class="cov0" title="0">if email, ok := claims["email"].(string); ok </span><span class="cov0" title="0">{
                        c.Set("email", email)
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func NewGatewayAuthMiddleware() *GatewayAuthMiddlewareHandler <span class="cov0" title="0">{
        return &amp;GatewayAuthMiddlewareHandler{}
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "encoding/json"
        "flyhorizons-bookingservice/config"
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/services/converter"
        "flyhorizons-bookingservice/services/errors"
        "flyhorizons-bookingservice/services/interfaces"
        "log"

        "github.com/rabbitmq/amqp091-go"
)

type BookingService struct {
        bookingRepo        interfaces.BookingRepository
        bookingConverter   converter.BookingConverter
        passengerConverter converter.PassengerConverter
        seatConverter      converter.SeatConverter
}

func NewBookingService(repo interfaces.BookingRepository, bookingConverter converter.BookingConverter, passengerConverter converter.PassengerConverter, seatConverter converter.SeatConverter) *BookingService <span class="cov8" title="1">{
        return &amp;BookingService{
                bookingRepo:        repo,
                bookingConverter:   bookingConverter,
                passengerConverter: passengerConverter,
                seatConverter:      seatConverter,
        }
}</span>

func (bookingService *BookingService) BookingExists(bookingID int) bool <span class="cov8" title="1">{
        for _, booking := range bookingService.bookingRepo.GetAll() </span><span class="cov8" title="1">{
                if booking.ID == bookingID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (bookingService *BookingService) GetByUserID(userID int) []models.Booking <span class="cov8" title="1">{
        bookingEntities := bookingService.bookingRepo.GetByUserID(userID)

        var bookings []models.Booking
        for _, bookingEntity := range bookingEntities </span><span class="cov8" title="1">{
                booking := bookingService.bookingConverter.ConvertBookingEntityToBooking(bookingEntity)
                bookings = append(bookings, booking)
        }</span>

        <span class="cov8" title="1">return bookings</span>
}

// TODO: Validate if the seat is available (double)
func (bookingService *BookingService) Create(booking models.Booking) (*models.Booking, error) <span class="cov8" title="1">{
        if bookingService.BookingExists(booking.ID) </span><span class="cov8" title="1">{
                return nil, errors.NewBookingExistsError(booking.ID, 409)
        }</span>

        <span class="cov0" title="0">var bookingEntity = bookingService.bookingConverter.ConvertBookingToBookingEntity(booking)
        var postBookingEntity = bookingService.bookingRepo.Create(bookingEntity)
        var postBooking = bookingService.bookingConverter.ConvertBookingEntityToBooking(postBookingEntity)

        // Once the booking has been created successfully, post the event to RabbitMQ
        // This is used for the EmailService to send emails to the passengers

        // Convert the booking to a JSON
        channel := config.RabbitMQClient.Channel

        body, err := json.Marshal(postBooking)

        err = channel.Publish(
                "",
                "booking_email_queue",
                false,
                false,
                amqp091.Publishing{
                        ContentType: "application/json",
                        Body:        body,
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("An error occurred while posting the messaging to RabbitMQ %v\n", err)
        }</span>

        <span class="cov0" title="0">return &amp;postBooking, nil</span>
}

func (bookingService *BookingService) DeleteByBookingID(id int) (bool, error) <span class="cov8" title="1">{
        if !bookingService.BookingExists(id) </span><span class="cov8" title="1">{
                return false, errors.NewBookingNotFoundError(id, 404)
        }</span>
        <span class="cov8" title="1">return bookingService.bookingRepo.DeleteByBookingID(id), nil</span>
}

func (bookingService *BookingService) Update(booking models.Booking) (*models.Booking, error) <span class="cov8" title="1">{
        if !bookingService.BookingExists(booking.ID) </span><span class="cov8" title="1">{
                return nil, errors.NewBookingNotFoundError(booking.ID, 404)
        }</span>

        <span class="cov8" title="1">var bookingEntity = bookingService.bookingConverter.ConvertBookingToBookingEntity(booking)
        var putBookingEntity = bookingService.bookingRepo.Update(bookingEntity)
        var putBooking = bookingService.bookingConverter.ConvertBookingEntityToBooking(putBookingEntity)

        return &amp;putBooking, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package converter

import (
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/models/enums"
        entities "flyhorizons-bookingservice/repositories/entity"
        "time"
)

type BookingConverter struct {
        passengerConverter PassengerConverter
        seatConverter      SeatConverter
}

func (bookingConverter *BookingConverter) ConvertBookingEntityToBooking(entity entities.BookingEntity) models.Booking <span class="cov8" title="1">{
        return models.Booking{
                ID:          entity.ID,
                UserID:      entity.UserID,
                FlightCode:  entity.FlightCode,
                FlightClass: enums.FlightClassFromInt(entity.FlightClass),
                Luggage:     enums.LuggageClassesFromJSONString(entity.Luggage),
                Seats:       bookingConverter.seatConverter.ConvertSeatEntitiesToSeats(entity.Seats),
                Passengers:  bookingConverter.passengerConverter.ConvertPassengerEntitiesToPassengers(entity.Passengers),
        }
}</span>

func (bookingConverter *BookingConverter) ConvertBookingToBookingEntity(booking models.Booking) entities.BookingEntity <span class="cov8" title="1">{
        bookingEntity := entities.BookingEntity{
                ID:          booking.ID,
                UserID:      booking.UserID,
                FlightCode:  booking.FlightCode,
                FlightClass: int(booking.FlightClass),
                CreatedAt:   time.Now(),
                Luggage:     enums.JSONStringToLuggageClasses(booking.Luggage),
        }

        bookingEntity.Passengers = bookingConverter.passengerConverter.ConvertPassengersToPassengerEntities(booking.Passengers, bookingEntity.ID)
        bookingEntity.Seats = bookingConverter.seatConverter.ConvertSeatsToSeatEntities(booking.Seats, bookingEntity.ID)

        return bookingEntity
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package converter

import (
        "flyhorizons-bookingservice/models"
        entities "flyhorizons-bookingservice/repositories/entity"
)

type PassengerConverter struct {
}

func (passengerConverter *PassengerConverter) ConvertPassengerEntitiesToPassengers(passengerEntities []entities.PassengerEntity) []models.Passenger <span class="cov8" title="1">{
        var passengers []models.Passenger
        for _, entity := range passengerEntities </span><span class="cov8" title="1">{
                passengers = append(passengers, models.Passenger{
                        ID:             entity.ID,
                        FullName:       entity.FullName,
                        DateOfBirth:    entity.DateOfBirth,
                        PassportNumber: entity.PassportNumber,
                        Email:          entity.Email,
                })
        }</span>
        <span class="cov8" title="1">return passengers</span>
}

func (passengerConverter *PassengerConverter) ConvertPassengersToPassengerEntities(passengers []models.Passenger, bookingID int) []entities.PassengerEntity <span class="cov8" title="1">{
        var passengerEntities []entities.PassengerEntity
        for _, passenger := range passengers </span><span class="cov8" title="1">{
                passengerEntities = append(passengerEntities, entities.PassengerEntity{
                        ID:             passenger.ID,
                        BookingID:      bookingID,
                        FullName:       passenger.FullName,
                        DateOfBirth:    passenger.DateOfBirth,
                        PassportNumber: passenger.PassportNumber,
                        Email:          passenger.Email,
                })
        }</span>
        <span class="cov8" title="1">return passengerEntities</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package converter

import (
        "flyhorizons-bookingservice/models"
        entities "flyhorizons-bookingservice/repositories/entity"
        "fmt"
)

type SeatConverter struct {
}

func (seatConverter *SeatConverter) ConvertSeatEntitiesToSeats(seatEntities []entities.SeatEntity) []models.Seat <span class="cov8" title="1">{
        var seats []models.Seat
        for _, entity := range seatEntities </span><span class="cov8" title="1">{
                seats = append(seats, models.Seat{
                        Row:       entity.Row,
                        Column:    entity.Column,
                        Available: true,
                })
        }</span>
        <span class="cov8" title="1">return seats</span>
}

func (seatConverter *SeatConverter) ConvertSeatsToSeatEntities(seats []models.Seat, bookingID int) []entities.SeatEntity <span class="cov8" title="1">{
        var seatEntities []entities.SeatEntity
        for _, seat := range seats </span><span class="cov8" title="1">{
                seatEntities = append(seatEntities, entities.SeatEntity{
                        BookingID: bookingID,
                        Row:       seat.Row,
                        Column:    seat.Column,
                })
        }</span>
        <span class="cov8" title="1">return seatEntities</span>
}

func (seatConverter *SeatConverter) ConvertSeatOptionEntitiesToSeats(seatOptionEntities []entities.SeatOptionEntity) []models.Seat <span class="cov8" title="1">{
        var seats []models.Seat
        for _, entity := range seatOptionEntities </span><span class="cov8" title="1">{
                fmt.Printf("Entity - Row: %d, Column: %s, Status: %v\n", entity.Row, entity.Column, entity.Status)
                seats = append(seats, models.Seat{
                        Row:       entity.Row,
                        Column:    entity.Column,
                        Available: entity.Status,
                })
        }</span>
        <span class="cov8" title="1">return seats</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package errors

import "fmt"

type BookingExistsError struct {
        ID int
}

func (e *BookingExistsError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Booking with the ID %d already exists", e.ID)
}</span>

func NewBookingExistsError(id int, errorCode int) *BookingExistsError <span class="cov0" title="0">{
        return &amp;BookingExistsError{ID: id}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package errors

import "fmt"

type BookingNotFoundError struct {
        ID int
}

func (e *BookingNotFoundError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Booking with the ID %d was not found", e.ID)
}</span>

func NewBookingNotFoundError(id int, errorCode int) *BookingNotFoundError <span class="cov0" title="0">{
        return &amp;BookingNotFoundError{ID: id}
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/services/converter"
        "flyhorizons-bookingservice/services/interfaces"
)

type SeatService struct {
        seatRepo      interfaces.SeatRepository
        seatConverter converter.SeatConverter
}

func NewSeatService(repo interfaces.SeatRepository, seatConverter converter.SeatConverter) *SeatService <span class="cov8" title="1">{
        return &amp;SeatService{
                seatRepo:      repo,
                seatConverter: seatConverter,
        }
}</span>

func (seatService *SeatService) GetByFlightCode(flightCode string) ([]models.Seat, error) <span class="cov8" title="1">{
        seatOptionEntities, err := seatService.seatRepo.GetByFlightCode(flightCode)
        seats := seatService.seatConverter.ConvertSeatOptionEntitiesToSeats(seatOptionEntities)
        return seats, err
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package load_test_utils

import (
        "fmt"
        "html/template"
        "os"
        "testing"
        "time"

        vegeta "github.com/tsenart/vegeta/v12/lib"
)

type LoadTestUtils struct {
}

func (utils *LoadTestUtils) LogMetrics(t *testing.T, metrics *vegeta.Metrics) <span class="cov0" title="0">{
        t.Logf("Requests: %d", metrics.Requests)
        t.Logf("Success Rate: %.2f%%", metrics.Success*100)
        t.Logf("Latency (mean): %s", metrics.Latencies.Mean)
        t.Logf("Latency (50th): %s", metrics.Latencies.P50)
        t.Logf("Latency (95th): %s", metrics.Latencies.P95)
        t.Logf("Latency (99th): %s", metrics.Latencies.P99)
        t.Logf("Throughput: %.2f req/s", metrics.Throughput)
        t.Logf("Errors: %v", metrics.Errors)
}</span>

func (utils *LoadTestUtils) EvaluateMetricsSuccess(t *testing.T, metrics *vegeta.Metrics) <span class="cov0" title="0">{
        if metrics.Success &lt; 0.95 </span><span class="cov0" title="0">{ // Fails if success rate is below 95%
                t.Errorf("Success rate too low: %.2f%% (expected &gt;= 95%%)", metrics.Success*100)
        }</span>
        <span class="cov0" title="0">if len(metrics.Errors) &gt; 0 </span><span class="cov0" title="0">{
                t.Errorf("Encountered errors: %v", metrics.Errors)
        }</span>
}

func (utils *LoadTestUtils) GenerateHTMLReport(t *testing.T, metrics *vegeta.Metrics, outputFile, title string) <span class="cov0" title="0">{
        // Create output file
        fullPath := fmt.Sprintf("./report/%s", outputFile)

        file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create HTML report file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Format the metrics for the template
        data := map[string]interface{}{
                "Title":       title,
                "Timestamp":   time.Now().Format(time.RFC3339),
                "Requests":    metrics.Requests,
                "SuccessRate": fmt.Sprintf("%.2f%%", metrics.Success*100),
                "LatencyMean": metrics.Latencies.Mean.String(),
                "Latency50th": metrics.Latencies.P50.String(),
                "Latency95th": metrics.Latencies.P95.String(),
                "Latency99th": metrics.Latencies.P99.String(),
                "LatencyMax":  metrics.Latencies.Max.String(),
                "Throughput":  fmt.Sprintf("%.2f", metrics.Throughput),
                "BytesIn":     metrics.BytesIn.Mean,
                "BytesOut":    metrics.BytesOut.Mean,
                "Errors":      metrics.Errors,
                "ErrorRate":   fmt.Sprintf("%.2f%%", (1-metrics.Success)*100),
                "Duration":    metrics.Duration.String(),
                "StatusCodes": metrics.StatusCodes,
        }

        tmpl, err := template.ParseFiles("templates/report_template.html")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to parse HTML template: %v", err)
        }</span>

        <span class="cov0" title="0">if err := tmpl.Execute(file, data); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to execute HTML template: %v", err)
        }</span>

        <span class="cov0" title="0">t.Logf("HTML report generated successfully: %s", outputFile)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mock_repositories

import (
        entities "flyhorizons-bookingservice/repositories/entity"
        "flyhorizons-bookingservice/services/interfaces"

        "github.com/stretchr/testify/mock"
)

type MockBookingRepository struct {
        mock.Mock
}

var _ interfaces.BookingRepository = (*MockBookingRepository)(nil)

func (m *MockBookingRepository) GetAll() []entities.BookingEntity <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]entities.BookingEntity)
}</span>

func (m *MockBookingRepository) GetByUserID(userID int) []entities.BookingEntity <span class="cov0" title="0">{
        args := m.Called(userID)
        return args.Get(0).([]entities.BookingEntity)
}</span>

func (m *MockBookingRepository) Create(booking entities.BookingEntity) entities.BookingEntity <span class="cov0" title="0">{
        args := m.Called(booking)
        return args.Get(0).(entities.BookingEntity)
}</span>

func (m *MockBookingRepository) DeleteByBookingID(ID int) bool <span class="cov0" title="0">{
        args := m.Called(ID)
        return args.Bool(0)
}</span>

func (m *MockBookingRepository) Update(booking entities.BookingEntity) entities.BookingEntity <span class="cov0" title="0">{
        args := m.Called(booking)
        return args.Get(0).(entities.BookingEntity)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package mock_repositories

import (
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/services/interfaces"

        "github.com/stretchr/testify/mock"
)

type MockBookingService struct {
        mock.Mock
}

var _ interfaces.BookingService = (*MockBookingService)(nil)

func (m *MockBookingService) BookingExists(bookingID int) bool <span class="cov0" title="0">{
        args := m.Called(bookingID)
        return args.Bool(0)
}</span>

func (m *MockBookingService) GetByUserID(userID int) []models.Booking <span class="cov0" title="0">{
        args := m.Called(userID)
        return args.Get(0).([]models.Booking)
}</span>

func (m *MockBookingService) Create(booking models.Booking) (*models.Booking, error) <span class="cov0" title="0">{
        args := m.Called(booking)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Booking), args.Error(1)</span>
}

func (m *MockBookingService) DeleteByBookingID(id int) (bool, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Bool(0), args.Error(1)
}</span>

func (m *MockBookingService) Update(booking models.Booking) (*models.Booking, error) <span class="cov0" title="0">{
        args := m.Called(booking)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Booking), args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mock_repositories

import (
        "github.com/gin-gonic/gin"
        "github.com/stretchr/testify/mock"
)

type MockGatewayAuthMiddleware struct {
        mock.Mock
        Role string
        ID   int
}

// Constructor to initialize MockGatewayAuthMiddleware with a role
func NewMockGatewayAuthMiddleware(role string, id int) *MockGatewayAuthMiddleware <span class="cov0" title="0">{
        return &amp;MockGatewayAuthMiddleware{
                Role: role,
                ID:   id,
        }
}</span>

// Middleware function now uses the role from the struct
func (m *MockGatewayAuthMiddleware) GatewayAuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Set("user_id", m.ID)
                c.Set("sub", m.ID)
                c.Set("role", m.Role)
                c.Set("email", "test@email.com")

                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mock_repositories

import (
        entities "flyhorizons-bookingservice/repositories/entity"
        "flyhorizons-bookingservice/services/interfaces"

        "github.com/stretchr/testify/mock"
)

type MockSeatRepository struct {
        mock.Mock
}

var _ interfaces.SeatRepository = (*MockSeatRepository)(nil)

func (m *MockSeatRepository) GetByFlightCode(flightCode string) ([]entities.SeatOptionEntity, error) <span class="cov0" title="0">{
        args := m.Called(flightCode)
        return args.Get(0).([]entities.SeatOptionEntity), nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package mock_repositories

import (
        "flyhorizons-bookingservice/models"
        "flyhorizons-bookingservice/services/interfaces"

        "github.com/stretchr/testify/mock"
)

type MockSeatService struct {
        mock.Mock
}

var _ interfaces.SeatService = (*MockSeatService)(nil)

func (m *MockSeatService) GetByFlightCode(flightCode string) ([]models.Seat, error) <span class="cov0" title="0">{
        args := m.Called(flightCode)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]models.Seat), args.Error(1)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
